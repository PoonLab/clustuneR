#' Wrapper for cluster.method functions
#' @param obj:  S3 object of class clusData
#' @param param.list:  list, each entry should be a list of threshold values
#'                     to pass to the clustering method
#' @param cluster.method:  function that returns data frame of known cases
#'                         annotated with cluster ID and growth
#' @param rangeID:  integer, unique index for rows generated by this function
#' @return list
#' @export
multi.cluster <- function(obj, param.list, cluster.method, rangeID=0) {
  # check that param.list has required inputs
  args <- formals(cluster.method)
  required <- names(args)[sapply(args, is.name)]
  
  cluster.range <- lapply(1:length(param.list), function(i) {
    pl <- param.list[[i]]
    pl$setID <- i
    pl$obj <- obj
    suppressWarnings(do.call(cluster.method, pl))
  })
  cluster.range <- do.call(rbind, cluster.range)
  suppressWarnings(cluster.range[, "RangeID" := rangeID])
  
  return(cluster.range)
}


#' Predictive analysis on clusters
#'
#' Fits predictive model of some outcome (by default, cluster growth) to some 
#' cluster-level variable (by default, cluster size). This fit is done for each 
#' cluster set. Multiple models can be inputted as a named list of functions taking 
#' in cluster data (see example)
#'
#' @param cluster.data: data.table, Inputted set(s) of clusters. Possibly multiple ranges
#' The following columns are required:
#'   Size: The number of sequences in clusters, not including new growth sequences.
#'   Growth: The number of new sequences added to the cluster.
#'   SetID: unique identifier for a set of clusters (obtained under given criteria)
#'   RangeID:
#' @param predictor.transformations: A named list of transformation functions for 
#' each predictor variable, *e.g.*, `list("Data"==sum)`. Because clustered meta data takes 
#' the form of a list these functions are often necessary to obtain a single, 
#' cluster-level variable.  Typical functions include `mean` and `median`.
#' @param predictive.models: A named list of functions, each of which applies a 
#' model to inputted cluster data (x). By default a "NullModel" example. Where
#' Growth is predicted only by cluster size
#' @return list, each entry labelled with SetID (to link back to the parameter list)
#'         Entries contain S3 objects of class "glm" or "lm".
#' @export
#' @example examples/fit.analysis_ex.R
fit.analysis <- function(cluster.data, 
                         predictor.transformations = list(),
                         predictive.models = list(
                           "NullModel" = function(x){
                             glm(Growth~Size, data=x, family="poisson")
                            })) {
  # Check inputs
  predictors <- names(predictor.transformations)
  mod.names <- names(predictive.models)
  
  setIDs <- unique(cluster.data[, SetID])
  if (!all((predictors) %in% colnames(cluster.data))) {
    stop("Predictors referenced in transform step are not in the range of ",
    "cluster data")
  }
  if (!("RangeID" %in% colnames(cluster.data))) {
    warning("No range ID, by default this will be set to 0 for all sets")
    cluster.data[, "RangeID" := 0]
  }

  # Transform cluster data for modelling based on inputs
  model.data <- cluster.data[, c("Header", "Size", "Growth", "SetID", "RangeID")]
  
  # append predictor variables and apply transformations
  if(!is.null(predictors)) {
    model.data[, (predictors) := lapply(predictors, function(x) {
      sapply(cluster.data[, get(x)], function(z) {
        (predictor.transformations[[x]])(z)
      })
    })]
  }

  # Obtain fit data for each cluster set
  model.fits <- lapply(setIDs, function(sid) {
    lapply(predictive.models, function(pmod) {
      suppressWarnings(list(pmod(model.data[SetID == sid, ])))
    })  # this could be run in parallel
  })
  cluster.analysis <- data.table::data.table(
    SetID=setIDs, 
    RangeID=sapply(split(model.data$RangeID, model.data$SetID), function(x) x[1])
  )
  # append model fits
  for (mod in 1:length(mod.names)) {
    cluster.analysis[[mod.names[mod]]] <- sapply(model.fits, function(x) x[[mod]])
  }
  
  return(cluster.analysis)
}


#' Get AIC values from an analysis
#'
#' Takes a cluster.analysis and extracts AIC values from columns containing model 
#' fits. Fit columns are automatically identified
#'
#' @param cluster.analysis:  data.table, from some predictive growth model analysis 
#'  generated by fit.analysis()
#' @param param.list: list, clustering thresholds used to generate cluster
#' data with multi.cluster()
#' @return The AIC data for all columns containing fit objects. The column specifying 
#'  setID is retained
#' @export
get.AIC <- function(cluster.analysis, param.list){
  # Identify which columns in cluster.analysis holds model fits
  which.models <- sapply(cluster.analysis[1,], function(x){
    any(attr(x[[1]], "class") %in% c("lm", "glm"))
    })
  which.models <- which(which.models)
  if (length(which.models)==0) {
    stop("No fits in the data set provided")
  }
  model.fits <- cluster.analysis[ , ..which.models]
  
  result <- data.frame(
    SetID=cluster.analysis$SetID,
    RangeID=cluster.analysis$RangeID
    )
  
  # append parameter values by set ID
  pnames <- names(param.list[[1]])
  for (pn in pnames) {
    result[[pn]] <- sapply(param.list, function(x) x[[pn]])
  }

  # extract AIC values from lm/glm objects into data frame
  temp <- apply(model.fits, 1, function(row) sapply(row, function(x) x$aic))
  result <- cbind(result, t(temp))
  
  return(result)
}




