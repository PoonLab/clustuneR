#' 
#' @param obj:  S3 object of class clusData
#' @param param.list:  list, each entry should be a list of threshold values
#'                     to pass to the clustering method
#' @param cluster.method:  function that returns data frame of known cases
#'                         annotated with cluster ID and growth
#' @param rangeID:  integer, unique index for rows generated by this function
multi.cluster <- function(obj, param.list, cluster.method, rangeID=0) {
  cluster.range <- lapply(1:length(param.list), function(i) {
    pl <- param.list[[i]]
    pl$setID <- i
    pl$obj <- obj
    suppressWarnings(do.call(cluster.method, pl))
  })
  for (i in 1:length(cluster.range)) {
    cluster.range[[i]]$RangeID <- rangeID
  }
  return(cluster.range)
}


#' Predictive analysis on clusters
#'
#' Fits predictive model of some outcome (by default, cluster growth) to some 
#' cluster-level variable (by default, cluster size). This fit is done for each 
#' cluster set. Multiple models can be inputted as a named list of functions taking 
#' in cluster data (see example)
#'
#' @param cluster.data: data.table, Inputted set(s) of clusters. Possibly multiple ranges
#' The following columns are required:
#'   Size: The number of sequences in clusters, not including new growth sequences.
#'   Growth: The number of new sequences added to the cluster.
#'   SetID: unique identifier for a set of clusters (obtained under given criteria)
#'   RangeID:
#' @param predictor.transformations: A named list of transformation functions for 
#' each predictor variable, *e.g.*, `list("Data"==sum)`. Because clustered meta data takes 
#' the form of a list these functions are often necessary to obtain a single, 
#' cluster-level variable.  Typical functions include `mean` and `median`.
#' @param predictive.models: A named list of functions, each of which applies a 
#' model to inputted cluster data (x). By default a "NullModel" example. Where
#' Growth is predicted only by cluster size
#' @return list, each entry labelled with SetID (to link back to the parameter list)
#'         Entries contain S3 objects of class "glm" or "lm".
#' @export
#' @example examples/fit.analysis_ex.R
fit.analysis <- function(cluster.data, 
                         predictor.transformations = list(),
                         predictive.models = list(
                           "NullModel" = function(x){
                             glm(Growth~Size, data=x, family="poisson")
                            })) {
  # Check inputs
  predictors <- names(predictor.transformations)
  mod.names <- names(predictive.models)
  
  setIDs <- sapply(cluster.data, function(x) unique(x$SetID))
  if (!all((predictors) %in% colnames(cluster.data[[1]]))) {
    stop("Predictors referenced in transform step are not in the range of cluster data")
  }

  # Transform cluster data for modelling based on inputs
  model.data <- lapply(cluster.data, function(df) {
    first.rows <- lapply(
      split(
        subset(df, select=c(SetID, RangeID, Cluster, Growth)), 
        df$Cluster
        ), 
      function(x) x[1,]
      )
    first.rows <- do.call(rbind, first.rows)
    
    # record cluster size
    first.rows$Size <- sapply(split(df$Header, df$Cluster), length)
    
    # append predictors after transformation
    for (i in 1:length(predictors)) {
      pr <- predictors[i]
      ptf <- predictor.transformations[[pr]]  # transformation function
      
      # FIXME: this treats all predictors as numeric, but what if they're factors?
      result <- sapply(split(as.numeric(df[[pr]]), df$Cluster), ptf)
      
      first.rows[[pr]] <- result
    }
    first.rows
  })

  # Obtain fit data for each cluster set
  model.fits <- lapply(model.data, function(df) {
    setID <- unique(df$SetID)
    lapply(predictive.models, function(pmod) {
      pmod(df)
    })
  })
  names(model.fits) <- setIDs
  
  return(model.fits)
}

#' Get AIC values from an analysis
#'
#' Extracts AIC values from model fits generated by fit.analysis(), returning
#' a data frame suitable for plotting.
#'
#' @param model.fits: list, return value from fit.analysis()
#' @param param.list: list, clustering thresholds used to generate cluster
#' data with multi.cluster()
#' @return data.frame
#' @export
#' @example examples/get.AIC_ex.R
get.AIC <- function(model.fits, param.list) {
  setIDs <- as.integer(names(model.fits))
  nsets <- length(setIDs)
  stopifnot(nsets == length(param.list))
  
  n.mods <- unique(sapply(model.fits, length))
  stopifnot(length(n.mods)==1)
  mod.names <- names(model.fits[[1]])
  
  result <- data.frame(
    setID=rep(setIDs, each=n.mods),
    model=rep(mod.names, times=nsets)
    )
  
  # append parameters from list
  pvals <- do.call(rbind, param.list)
  if (ncol(pvals) == 1) {
    # handle case where only one parameter
    result[[colnames(pvals)]] <- unlist(pvals)[result$setID]
  } else {
    result <- cbind(result, pvals[result$setID, ])  
  }
  
  result$AIC <- sapply(1:nrow(result), function(i) {
    fit <- model.fits[[ result$setID[i] ]][[ result$model[i] ]]
    fit$aic
  })
  class(result) <- "clusResult"

  return(result)
}


#' Summarize AIC results in a plot
#' @param obj:  S3 object of class "clusResult" from get.AIC()
plot.clusResult <- function(obj) {
  
}

