return(df)
})) %>%
select(ID1, ID2, Distance) %>%
arrange(ID1, ID2)
all(edge_list_check$ID1 == edge_list_true$ID1) ## TRUE
all(edge_list_check$ID2 == edge_list_true$ID2) ## TRUE
# Distances are ~10% bigger at most and <1% bigger on average
mean(edge_list_check$Distance - edge_list_true$Distance) / mean(edge_list_check$Distance)
max(edge_list_check$Distance - edge_list_true$Distance) / mean(edge_list_check$Distance)
g <- create.graph(seq.info, edge.info, which.new)
any(g$growth.resolved$NewHeader %in% g$growth.resolved$OldHeader) ## FALSE
all(sapply(g$growth.resolved$NewHeader, function(x){
x_edges <- edge.info[x,]
retro_x_edges <- x_edges[!grepl(max.year, names(x_edges))]
min_retro_true <- names(retro_x_edges)[which.min(retro_x_edges)]
min_retro_check <- g$growth.resolved %>% filter(NewHeader == x) %>% pull(OldHeader)
min_retro_true==min_retro_check
})) ## TRUE
require(clustuneR)
require(ape)
require(lubridate)
require(dplyr)
seqs <- ape::read.FASTA("data/na.fasta", type="DNA")
# parse sequence headers (alternatively import from another file)
seq.info <- pull.headers(seqs, sep="_", var.names=c('accession', 'coldate', 'subtype'),
var.transformations=c(as.character, as.Date, as.factor))
all(seq.info$Header %in% names(edge.info[1,])) ## TRUE
max.year <- max(year(seq.info$coldate))
which.new <- which(year(seq.info$coldate) == max.year)
which.old <- which(year(seq.info$coldate) < max.year)
edge.info <- ape::dist.dna(seqs, pairwise.deletion = T, as.matrix = T, model = "TN93")
edge_list_true  <- fread('data/na_tn93_check.tsv') %>%
arrange(ID1, ID2) %>% as.data.frame()
edge_list_check <- bind_rows(lapply(1:(nrow(edge.info)-1), function(i){
df <- data.frame(
ID2 = names(edge.info[i,])[(i+1):nrow(edge.info)],
Distance = unname(edge.info[(i+1):nrow(edge.info),i])
)
df$ID1 <- names(edge.info[i,])[i]
return(df)
})) %>%
select(ID1, ID2, Distance) %>%
arrange(ID1, ID2)
all(edge_list_check$ID1 == edge_list_true$ID1) ## TRUE
all(edge_list_check$ID2 == edge_list_true$ID2) ## TRUE
# Distances are ~10% bigger at most and <1% bigger on average
mean(edge_list_check$Distance - edge_list_true$Distance) / mean(edge_list_check$Distance)
max(edge_list_check$Distance - edge_list_true$Distance) / mean(edge_list_check$Distance)
g <- create.graph(seq.info, edge.info, which.new)
any(g$growth.resolved$NewHeader %in% g$growth.resolved$OldHeader) ## FALSE
all(sapply(g$growth.resolved$NewHeader, function(x){
x_edges <- edge.info[x,]
retro_x_edges <- x_edges[!grepl(max.year, names(x_edges))]
min_retro_true <- names(retro_x_edges)[which.min(retro_x_edges)]
min_retro_check <- g$growth.resolved %>% filter(NewHeader == x) %>% pull(OldHeader)
min_retro_true==min_retro_check
})) ## TRUE
require(clustuneR)
require(ape)
require(lubridate)
require(dplyr)
seqs <- ape::read.FASTA("data/na.fasta", type="DNA")
# parse sequence headers (alternatively import from another file)
seq.info <- pull.headers(seqs, sep="_", var.names=c('accession', 'coldate', 'subtype'),
var.transformations=c(as.character, as.Date, as.factor))
all(seq.info$Header %in% names(edge.info[1,])) ## TRUE
max.year <- max(year(seq.info$coldate))
which.new <- which(year(seq.info$coldate) == max.year)
which.old <- which(year(seq.info$coldate) < max.year)
edge.info <- ape::dist.dna(seqs, pairwise.deletion = T, as.matrix = T, model = "TN93")
setwd('clustuneR/')
seqs <- ape::read.FASTA("data/na.fasta", type="DNA")
# parse sequence headers (alternatively import from another file)
seq.info <- pull.headers(seqs, sep="_", var.names=c('accession', 'coldate', 'subtype'),
var.transformations=c(as.character, as.Date, as.factor))
all(seq.info$Header %in% names(edge.info[1,])) ## TRUE
max.year <- max(year(seq.info$coldate))
which.new <- which(year(seq.info$coldate) == max.year)
which.old <- which(year(seq.info$coldate) < max.year)
edge.info <- ape::dist.dna(seqs, pairwise.deletion = T, as.matrix = T, model = "TN93")
edge_list_true  <- fread('data/na_tn93_check.tsv') %>%
arrange(ID1, ID2) %>% as.data.frame()
edge_list_check <- bind_rows(lapply(1:(nrow(edge.info)-1), function(i){
df <- data.frame(
ID2 = names(edge.info[i,])[(i+1):nrow(edge.info)],
Distance = unname(edge.info[(i+1):nrow(edge.info),i])
)
df$ID1 <- names(edge.info[i,])[i]
return(df)
})) %>%
select(ID1, ID2, Distance) %>%
arrange(ID1, ID2)
all(edge_list_check$ID1 == edge_list_true$ID1) ## TRUE
all(edge_list_check$ID2 == edge_list_true$ID2) ## TRUE
# Distances are ~10% bigger at most and <1% bigger on average
mean(edge_list_check$Distance - edge_list_true$Distance) / mean(edge_list_check$Distance)
max(edge_list_check$Distance - edge_list_true$Distance) / mean(edge_list_check$Distance)
g <- create.graph(seq.info, edge.info, which.new)
any(g$growth.resolved$NewHeader %in% g$growth.resolved$OldHeader) ## FALSE
all(sapply(g$growth.resolved$NewHeader, function(x){
x_edges <- edge.info[x,]
retro_x_edges <- x_edges[!grepl(max.year, names(x_edges))]
min_retro_true <- names(retro_x_edges)[which.min(retro_x_edges)]
min_retro_check <- g$growth.resolved %>% filter(NewHeader == x) %>% pull(OldHeader)
min_retro_true==min_retro_check
})) ## TRUE
g
# generate cluster sets under varying parameter settings
param.list <- lapply(seq(0.001, 0.04, 0.001), function(x) {list(g=g, dist.thresh=x)})
cluster.sets <- multi.cluster(component.cluster, param.list)
cluster.sets
cluster.sets
growth_total <- sapply(1:20, function(i){sum((cluster.sets[SetID == i])$Growth)})
all(growth_total == cummax(growth_total)) ## FALSE - SHOULD ABSOLUTELY BE TRUE
growth_total
param.list[[11]]
growth_total[[1]]
growth_total[[11]]
growth_total[[10]]
dist.thresh <- 0.11
dist.thresh <- 0.011
setID = 0
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
}
cluster.set <- g$seq.info[!(New), lapply(seq.cols, function(nm) {
list(get(nm))
}), by = Cluster]
cluster.set[, "Size" := length(V1[[1]]), by = 1:nrow(cluster.set)]
colnames(cluster.set) <- c("ClusterID", seq.cols, "Size")
cluster.set$New <- NULL
cluster.set <- cluster.set[order(ClusterID),]
# Attach growth info and set ID
growth <- table(g$seq.info[(New) & (Cluster %in% cluster.set$ClusterID), Cluster])
cluster.set[, "Growth" := 0]
cluster.set[ClusterID %in% as.numeric(names(growth)), Growth := as.numeric(growth)]
growth
cluster.set
#' Create clusters based on the components of a graph
#'
#' Edges are filtered away using a distance threshold to break up the completely
#' connected graph such that only similar edges remain.
#'
#' @param g: The input graph, annotated with vertex, edge, and growth resolution
#' information
#' @param dist.thresh: The maximum distance defining which edges are filtered.
#' A higher distance threshold implies a larger average cluster size
#' @param setID: A numeric identifier for this cluster set.
#' @return A set of clusters as a data.table. See example cluster.ex object
#' documentation for an example of clustered sequence data + meta data
#' @export
#' @example examples/component.cluster_ex.R
component.cluster <- function(g, dist.thresh = 0, setID = 0) {
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
}
cluster.set <- g$seq.info[!(New), lapply(seq.cols, function(nm) {
list(get(nm))
}), by = Cluster]
cluster.set[, "Size" := length(V1[[1]]), by = 1:nrow(cluster.set)]
colnames(cluster.set) <- c("ClusterID", seq.cols, "Size")
cluster.set$New <- NULL
cluster.set <- cluster.set[order(ClusterID),]
# Attach growth info and set ID
growth <- table(g$seq.info[(New) & (Cluster %in% cluster.set$ClusterID), Cluster])
cluster.set[, "Growth" := 0]
cluster.set[ClusterID %in% as.numeric(names(growth)), Growth := as.numeric(growth)]
cluster.set[, "DistThresh" := dist.thresh]
cluster.set[, "SetID" := setID]
return(cluster.set)
}
# generate cluster sets under varying parameter settings
param.list <- lapply(seq(0.001, 0.04, 0.001), function(x) {list(g=g, dist.thresh=x)})
cluster.sets <- multi.cluster(component.cluster, param.list)
multi.cluster <- function(cluster.method, param.list, mc.cores = 1, rangeID = 0) {
# Cluster method loop
cluster.range <- parallel::mclapply(1:length(param.list), function(i) {
print(i)
x <- param.list[[i]]
x$setID <- i
suppressWarnings(do.call(cluster.method, x))
}, mc.cores = mc.cores)
cluster.range <- dplyr::bind_rows(cluster.range)
suppressWarnings(cluster.range[, "RangeID" := rangeID])
return(cluster.range)
}
cluster.sets <- multi.cluster(component.cluster, param.list)
param.list[[34]]
dist.thresh <- 0.034
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
filtered.edges
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
print(seq.info$Cluster)
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
}
cluster.set
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
which(g$seq.info$Cluster != previous.cluster)
}
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(which(g$seq.info$Cluster != previous.cluster))
}
g$seq.info$Cluster[which(g$seq.info$Cluster != previous.cluster)]
which(g$seq.info$Cluster != previous.cluster)
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(which(g$seq.info$Cluster != previous.cluster))
g$seq.info$Cluster[which(g$seq.info$Cluster != previous.cluster)]
previous.cluster[which(g$seq.info$Cluster != previous.cluster)]
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(which(g$seq.info$Cluster != previous.cluster))
g$seq.info$Cluster[which(g$seq.info$Cluster != previous.cluster)]
previous.cluster[which(g$seq.info$Cluster != previous.cluster)]
g$seq.info[which(g$seq.info$Cluster != previous.cluster)]
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
g$seq.info[which(g$seq.info$Cluster != previous.cluster)]
i <- 185
which(filtered.edges[i, -i])
g$seq.info[i]
i <- 187
g$seq.info[which(filtered.edges[i, -i]),]
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
g$seq.info[which(filtered.edges[i, -i]),]
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
i <- 185
g$seq.info[which(filtered.edges[i, -i])]
g$seq.info[i]
i <- 187
g$seq.info[which(filtered.edges[i, -i])]
g$seq.info[i]
i <- 188
g$seq.info[i]
g$seq.info[which(filtered.edges[i, -i])]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)]
)
g$seq.info$Index <- 1:nrow(g$seq.info)
g$seq.info$Index
g$seq.info
g$seq.info[185]
g$seq.info[which(filtered.edges[i, -i])]
i <- 185
g$seq.info[which(filtered.edges[i, -i])]
g$edge.info
g$edge.info[185, 188]
g$edge.info[188, 185]
filtered.edges
filtered.edges[188, 185]
filtered.edges[188, 185]
filtered.edges[185, 188]
filtered.edges[i, -i]
i
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
i <- 185
g$seq.info[which(filtered.edges[i, -i]),]
i <- 187
g$seq.info[which(filtered.edges[i, -i]),]
i <- 188
g$seq.info[which(filtered.edges[i, -i]),]
i <- 186
g$seq.info[which(filtered.edges[i, -i]),]
filtered.edges[186, 185]
filtered.edges[185, 186]
i <- 185
g$seq.info[which(filtered.edges[i, -i]),]
names(filtered.edges)[186]
names(g$edge.info)[186]
g$edge.info
names(g$edge.info[186,185])
g$edge.info[186,185]
g$edge.info[185,186]
names(g$edge.info[1,])
names(g$edge.info[1,])][186]
names(g$edge.info[1,])[186]
g$seq.info[which(filtered.edges[i, -i]),]
which(filtered.edges[i, -i])
diag(g$edge.info)
max(diag(g$edge.info))
diag(filtered.edges)
diag(filtered.edges) <- F
diag(filtered.edges)
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
diag(filtered.edges) <- F
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, -i]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
}
# Filter edges above the distance threshold and prepare for component finding algorithm
# All edges from a new sequence are filtered except for their "growth-resolved" edge
filtered.edges <- g$edge.info <= dist.thresh
diag(filtered.edges) <- F
filtered.edges[which(g$seq.info$New), ] <- F
filtered.edges[,which(g$seq.info$New)]  <- F
filtered.edges[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <-
g$edge.info[g$growth.resolved$NewHeader, g$growth.resolved$OldHeader] <= dist.thresh
filtered.edges[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <-
g$edge.info[g$growth.resolved$OldHeader, g$growth.resolved$NewHeader] <= dist.thresh
# Run homogenization algorithm to label sequences with their cluster
seq.cols <- colnames(g$seq.info)
previous.cluster <- rep(0, nrow(g$seq.info))
g$seq.info[, "Cluster" := 1:nrow(g$seq.info)]
while (any(g$seq.info$Cluster != previous.cluster)) {
previous.cluster <- g$seq.info$Cluster
g$seq.info[, Cluster := sapply(1:nrow(g$seq.info), function(i) {
x <- g$seq.info[which(filtered.edges[i, ]), Cluster]
if (length(x) == 0) {
return(i)
} else {
return(min(x))
}
})]
print(g$seq.info[which(g$seq.info$Cluster != previous.cluster)])
}
